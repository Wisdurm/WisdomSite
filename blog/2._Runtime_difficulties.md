# Been a bit

Hello. I haven't been keeping this blog updated, with the main reason being that idk it feels kinda weird
to write stuff here. You certainly won't be seeing anything too personal any time soon.  
What I've wanted to write about today is some of my current affairs with the Runtime programming language, 
a programming language that I've been working on for around 6 months (although not super consistently).  

Recently I've had to start confronting some of the harder problems I've left for myself in the code.
One such thing is

## Evaluation

Evaluation is one of the most important things in Runtime. It's the key to how both variables and functions
are able to coexist as the same type. However, due to the complicated nature of it works as well as how objects
and the ast-tree interact in the interpreter, I personally have quite a hard time mentally understanding it.
I have general image of it, but when I run into some complex problems rooted deep within it, I have to
spend hours in GDB just to figure out the root cause. And many a time, I've come across bugs that weren't bugs
at all, and are just logical consequences of how the language is structured.  

An example is that it's normally impossible
for a function to return an object, be it a Runtime function, a built-in standard library function or even a shared
library function. This is because if you assign the return value with `Assign()`, it will evaluate it down to a single
value (by taking the last member), whereas with a non-evaluating function like `Object()`, it will simply assign the
call of the function to an object, meaning it will just get evaluated down later on anyway.  

This is quite a significant problem, because while you could technically just force all Runtime functions you want to
return an object to instead modify an argument passed by reference, you simply cannot do the same if you want to use a
pre-existing C library. The "solution" to this problem is the standard library function `Copy()`, which uses a special
form of evaluation currently called "soft evaluation" (for lack of a better name). The technical explanation for this is
that it doesn't "double evaluate", that is, recursively evaluate until it returns a value. What does this mean in practice?
I don't really know! When at one point I completely removed "hard" evaluation, the only test that didn't pass was a member
function one. So I guess methods are the one thing holding Runtime back, since they keep breaking when I make changes, and
getting them to work at all was a nightmare and almost made me consider giving up on this language.

## The live interpreter

The live interpreter is pretty cool isn't it? You can do the same things as you would in scripts, but it's easier to experiment
with functions and objects! Or at least that's how it would be in an ideal world... The truth is that the live interpreter fundamentally
works in a completely different way than the non-live interpreter. And this difference can be pretty catasthropic... I think. I had actually
never really fully cognitized the problems with the live interpreter until I had to fix member functions, which initially only functioned in the
live interpreter! I'm sure there's plently of other problems I've yet to face, such as maybe scope (which there currently aren't any tests for!),
which relies on some recursive logic that may not function correctly in the live interpreter.

The technical explanation is one I can only partially give, since I really can't mentally picture how the non-live interpreter works, due to its
esotericness. The live interpreter works exactly how you would expect. You give it an object call, and it calls the objects. That's basically about
as complex as it gets. The non-live interpreter however actually goes through all the code in a first pass that it uses to generate the main
object, and only then it will call the main object. During the first pass nothing gets evaluated, but objects which are only one layer down, become
proper objects, whereas layers below simply get stored as the ast tree. The main object call will then actually evaluate all members of the main
object. Make sense? No? Well yeah I don't really get it either.

One thing to note here is that objects don't necessarily get called in both interpreters. That is, the internal callObject() function may not always
be called in the same places if the same piece of code is called in the live and non-live interpreters. How? Idk :(

## Shared libraries and the future of the language

The last thing I'd like to touch on at the moment is the future of the language, and how shared libraries are related to this in two ways.  

First of Windows. When I started work on Runtime, I was still primarily a Windows user, and even though I had a laptop running Linux, I wasn't
particularly interested in supporting it. I mean I wasn't against it, but I wasn't a fan of how much work I imagined would be involved. Cut to now,
when that same dual-boot laptop is the only machine I have with Windows installed. And much like then, I have a sort of apathy towards supporting
the other system. It isn't like I don't want to, but when adding GNU readline as a shared library, I left Windows compatability for the future,
and now with the shared library loading I have no idea how I would do something like that on Windows, and I will definitely leave it out of 0.11
just because I can't be bothered right now. The shared library support has already taken a lot of time, largely because I'm not super motivated 
to work on it. However apart from the work load a new consideration has ignited within my brain.

Professionality is something that I've though about in varying ways throughout this project. Runtime has always been a hobby project, first because
its stress free and fun that way, but secondly also because I don't think I'll ever actually contribute anything useful to the world of code.
But in the beginning I did try to put effort into commits and code being "appropriate". In terms of commits, commit messages haven't
been doing too hot, but structuring work on the code by creating multiple branches and splitting changes into appropriate commits is something I've
tried to focus on.

But disregarding all that boring stuff, the one thing that's made me think this language could actually have even a super niche use case is the shared
libraries. I originally started work on them because a friend gave me the idea, and I figured it would be an interesting and enlightening experience
(and it sure has). Now that its actually approaching completion, I've though about how this could give Runtime a very niche use case, due to the extreme
simplicity of creating bindings for a library (literally a single `Bind()` function) and also due to how simple Runtime is (in theory, of course
evaluation screws up all of that in practice though :)  
I'd really like to automate binding at some point, maybe even adding a custom backend for SWIG?

## About it

That's about all I have to write about today. If nothing else, I certainly don't have difficulties yapping about Runtime.
